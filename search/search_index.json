{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#code.bpf.BestParameterFinder","title":"<code>BestParameterFinder</code>","text":"Source code in <code>code\\bpf.py</code> <pre><code>class BestParameterFinder():\n\tdef nInfUniform(self, voltages):\n\t\tvoltages.sort()\n\t\tuniform = np.array([x / (len(voltages) - 1) for x in range(len(voltages))])\n\n\t\treturn np.linalg.norm(abs(voltages - uniform))\n\n\tdef nInfExp(self, voltages, base=10):\n\t\tglobal dist\n\n\t\tvoltages.sort()\n\n\t\tif (len(dist) != len(voltages)):\n\t\t\tdist = np.array([np.pow(base, (x / (len(voltages) - 1)) - 1) for x in range(len(voltages))])\n\n\t\treturn np.linalg.norm(abs(voltages - dist))\n\n\tdef median(self, voltages, value=0.5):\n\t\tvoltages.sort()\n\t\treturn abs(voltages[int(len(voltages) / 2)] - value)\n\n\tdef minimum(self, voltages, value=0.1):\n\t\tvoltages.sort()\n\t\treturn abs(voltages[0] - value)\n\n\tdef minWithStd(self, voltages, value=0.1):\n\t\tvoltages.sort()\n\t\treturn abs(voltages[0] - value) / np.std(voltages)\n\n\tdef expWithStd(self, voltages, base=10):\n\t\treturn self.nInfExp(voltages, base) / np.std(voltages)\n\n\tdef __init__(self, metric=expWithStd):\n\t\tself.metric = metric\n\t\tself.p_g = None\n\t\tself.c = None\n\n\tdef setResistanceToGround(self, p_g):\n\t\tself.p_g = np.log(p_g)\n\n\tdef setKernelParameter(self, c):\n\t\tself.c = np.log(c)\n\n\tdef calculateFor(self, landmarks, data, c, p_g, approx=False, approx_epsilon=None, approx_iters=None):\n\t\t# print(type(data))\n\n\t\tif (isinstance(data, create_data.Data)):\n\t\t\tmeanProblem = voltage.Problem(data)\n\t\t\tmeanProblem.timeStart()\n\t\t\tmeanProblem.setKernel(meanProblem.gaussiankernel)\n\t\t\t# print(\"before\")\n\t\t\tmeanProblem.setWeights(np.exp(c))\n\t\t\t# print(\"after\")\n\t\t\t# print(meanProblem)\n\n\t\tif (isinstance(data, kmeans.Partitions)):\n\t\t\tpartitions = data\n\n\t\t\tmeanProblem = voltage.Problem(partition.centers)\n\t\t\tmeanProblem.timeStart()\n\t\t\tmeanProblem.setKernel(meanProblem.gaussiankernel)\n\t\t\tmeanProblem.setPartitionWeights(partition, np.exp(c))\n\t\t\t# print(meanProblem)\n\n\t\t# print(meanProblem)\n\n\t\tmeanProblem.addUniversalGround(np.exp(p_g))\n\t\tmeanProblem.addLandmarks(landmarks)\n\n\t\tdiff1 = meanProblem.timeEnd()\n\t\t# print(diff1)\n\n\t\tif (approx):\n\t\t\tvoltages = np.array(voltage.Solver(meanProblem).approximate_voltages(approx_epsilon, approx_iters))\n\t\telse:\n\t\t\tvoltages = np.array(voltage.Solver(meanProblem).compute_voltages())\n\n\t\tdiff2 = meanProblem.timeEnd()\n\t\t# print(diff2)\n\n\t\tif (self.metric):\n\t\t\treturn self.metric(self, voltages)\n\t\telse:\n\t\t\treturn voltages, meanProblem\n\n\tdef bestParameterFinder(self, landmarks, data, minBound=-25, maxBound=-1, granularity=5, epsilon=1, approx=None):\n\t\t\"\"\"\n\t\tFinds the best parameters (C and P_G) for a solver based on voltage distribution minimization.\n\n\t\tThis function searches for optimal parameters `C` and `P_G` by iterating over exponent values in \n\t\ta specified range, computing voltages using a solver, and minimizing some metric\n\t\tbetween the voltage distribution and a uniform distribution.\n\n\t\tParameters:\n\t\t-----------\n\t\tkernel : object\n\t\t\tThe kernel function or object used to compute partition weights.\n\t\tlandmarks : list\n\t\t\tA list of landmark points used in the solver.\n\t\tdata : object\n\t\t\tEither a data object or a partition object containing centers used in the solver.\n\t\tnInfUniform : function (list of floating point values -&gt; floating point value)\n\t\t\tA function that is used to quantify if voltages are good or bad, the smaller the better\n\t\tminBound : int, optional (default=1e-5)\n\t\t\tThe minimum value to consider for `C` and `P_g` as 10^minBound.\n\t\tmaxBound : int, optional (default=1e5)\n\t\t\tThe maximum value to consider for `C` and `P_g` as 10^maxBound.\n\n\t\tReturns:\n\t\t--------\n\t\ttuple\n\t\t\tA tuple (bestC, bestG), where:\n\t\t\t- bestC (float): The optimized value for parameter C.\n\t\t\t- bestG (float): The optimized value for parameter P_g.\n\t\t\"\"\"\n\n\t\twindow_size = (maxBound - minBound) / 2\n\n\t\tbestc = minBound + window_size\n\t\tbestg = minBound + window_size\n\n\t\tval = float('inf')\n\n\t\twhile window_size &gt; epsilon:\n\t\t\tprint(window_size, np.exp(bestc), np.exp(bestg))\n\n\t\t\tcs = [bestc + x * window_size / granularity for x in range(-granularity + 1, granularity)]\n\t\t\tgs = [bestg + x * window_size / granularity for x in range(-granularity + 1, granularity)]\n\n\t\t\tif self.c != None:\n\t\t\t\tcs = [self.c]\n\t\t\tif self.p_g != None:\n\t\t\t\tgs = [self.p_g]\n\n\t\t\tfor c in cs:\n\t\t\t\tfor g in gs:\n\t\t\t\t\t# print(c, g)\n\t\t\t\t\ttry:\n\t\t\t\t\t\tif (approx == None):\n\t\t\t\t\t\t\ttempval = self.calculateFor(landmarks, data, c, g)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\ttempval = self.calculateFor(landmarks, data, c, g, approx=True, approx_iters=approx)\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t# print(tempval)\n\t\t\t\t\t\tif (val &gt; tempval):\n\t\t\t\t\t\t\t# print(c)\n\t\t\t\t\t\t\t# print(g)\n\t\t\t\t\t\t\t# print(tempval)\n\n\t\t\t\t\t\t\tbestc = c\n\t\t\t\t\t\t\tbestg = g\n\t\t\t\t\t\t\tval = tempval\n\t\t\t\t\texcept ValueError as e:\n\t\t\t\t\t\tpass\n\t\t\t\t\t\t# print(\"Invalid\")\n\n\n\t\t\twindow_size /= granularity\n\n\t\treturn np.exp(bestc), np.exp(bestg)\n\n\tdef multiLandmarkBestParams(self, landmarks, data, start=0, epsilon=1, approx=None):\n\t\tpass\n\n\tdef visualizations(self, voltages, fileStarter):\n\t\tpoints = np.array(list(map(list, zip(*voltages))))\n\n\t\t# print(points.shape)\n\n\t\t# PCA\n\t\tpca = PCA(n_components=2)\n\t\tpoints_2d = pca.fit_transform(points)\n\n\t\t# print(points_2d.shape)\n\n\t\tplt.scatter(points_2d[:, 0], points_2d[:, 1], s=10)\n\t\tplt.xlabel(\"PCA Component 1\")\n\t\tplt.ylabel(\"PCA Component 2\")\n\t\tplt.title(\"PCA Projection of Solver Outputs\")\n\n\t\tplt.savefig(fileStarter + \"_PCA.png\")\n\t\tplt.clf()\n\n\t\t# MDS\n\t\tmds = MDS(n_components=2, random_state=42)\n\t\ttransformed_points = mds.fit_transform(points)\n\n\t\tplt.figure(figsize=(8, 6))\n\t\tplt.scatter(transformed_points[:, 0], transformed_points[:, 1], c='blue', edgecolors='black')\n\n\t\tplt.xlabel(\"MDS Dimension 1\")\n\t\tplt.ylabel(\"MDS Dimension 2\")\n\t\tplt.title(\"Multidimensional Scaling (MDS) to 2D\")\n\n\t\tplt.savefig(fileStarter + \"_MDS.png\")\n\t\tplt.clf()\n</code></pre>"},{"location":"reference/#code.bpf.BestParameterFinder.bestParameterFinder","title":"<code>bestParameterFinder(landmarks, data, minBound=-25, maxBound=-1, granularity=5, epsilon=1, approx=None)</code>","text":"<p>Finds the best parameters (C and P_G) for a solver based on voltage distribution minimization.</p> <p>This function searches for optimal parameters <code>C</code> and <code>P_G</code> by iterating over exponent values in  a specified range, computing voltages using a solver, and minimizing some metric between the voltage distribution and a uniform distribution.</p>"},{"location":"reference/#code.bpf.BestParameterFinder.bestParameterFinder--parameters","title":"Parameters:","text":"<p>kernel : object         The kernel function or object used to compute partition weights. landmarks : list         A list of landmark points used in the solver. data : object         Either a data object or a partition object containing centers used in the solver. nInfUniform : function (list of floating point values -&gt; floating point value)         A function that is used to quantify if voltages are good or bad, the smaller the better minBound : int, optional (default=1e-5)         The minimum value to consider for <code>C</code> and <code>P_g</code> as 10^minBound. maxBound : int, optional (default=1e5)         The maximum value to consider for <code>C</code> and <code>P_g</code> as 10^maxBound.</p>"},{"location":"reference/#code.bpf.BestParameterFinder.bestParameterFinder--returns","title":"Returns:","text":"<p>tuple         A tuple (bestC, bestG), where:         - bestC (float): The optimized value for parameter C.         - bestG (float): The optimized value for parameter P_g.</p> Source code in <code>code\\bpf.py</code> <pre><code>def bestParameterFinder(self, landmarks, data, minBound=-25, maxBound=-1, granularity=5, epsilon=1, approx=None):\n\t\"\"\"\n\tFinds the best parameters (C and P_G) for a solver based on voltage distribution minimization.\n\n\tThis function searches for optimal parameters `C` and `P_G` by iterating over exponent values in \n\ta specified range, computing voltages using a solver, and minimizing some metric\n\tbetween the voltage distribution and a uniform distribution.\n\n\tParameters:\n\t-----------\n\tkernel : object\n\t\tThe kernel function or object used to compute partition weights.\n\tlandmarks : list\n\t\tA list of landmark points used in the solver.\n\tdata : object\n\t\tEither a data object or a partition object containing centers used in the solver.\n\tnInfUniform : function (list of floating point values -&gt; floating point value)\n\t\tA function that is used to quantify if voltages are good or bad, the smaller the better\n\tminBound : int, optional (default=1e-5)\n\t\tThe minimum value to consider for `C` and `P_g` as 10^minBound.\n\tmaxBound : int, optional (default=1e5)\n\t\tThe maximum value to consider for `C` and `P_g` as 10^maxBound.\n\n\tReturns:\n\t--------\n\ttuple\n\t\tA tuple (bestC, bestG), where:\n\t\t- bestC (float): The optimized value for parameter C.\n\t\t- bestG (float): The optimized value for parameter P_g.\n\t\"\"\"\n\n\twindow_size = (maxBound - minBound) / 2\n\n\tbestc = minBound + window_size\n\tbestg = minBound + window_size\n\n\tval = float('inf')\n\n\twhile window_size &gt; epsilon:\n\t\tprint(window_size, np.exp(bestc), np.exp(bestg))\n\n\t\tcs = [bestc + x * window_size / granularity for x in range(-granularity + 1, granularity)]\n\t\tgs = [bestg + x * window_size / granularity for x in range(-granularity + 1, granularity)]\n\n\t\tif self.c != None:\n\t\t\tcs = [self.c]\n\t\tif self.p_g != None:\n\t\t\tgs = [self.p_g]\n\n\t\tfor c in cs:\n\t\t\tfor g in gs:\n\t\t\t\t# print(c, g)\n\t\t\t\ttry:\n\t\t\t\t\tif (approx == None):\n\t\t\t\t\t\ttempval = self.calculateFor(landmarks, data, c, g)\n\t\t\t\t\telse:\n\t\t\t\t\t\ttempval = self.calculateFor(landmarks, data, c, g, approx=True, approx_iters=approx)\t\t\t\t\t\t\t\n\n\t\t\t\t\t# print(tempval)\n\t\t\t\t\tif (val &gt; tempval):\n\t\t\t\t\t\t# print(c)\n\t\t\t\t\t\t# print(g)\n\t\t\t\t\t\t# print(tempval)\n\n\t\t\t\t\t\tbestc = c\n\t\t\t\t\t\tbestg = g\n\t\t\t\t\t\tval = tempval\n\t\t\t\texcept ValueError as e:\n\t\t\t\t\tpass\n\t\t\t\t\t# print(\"Invalid\")\n\n\n\t\twindow_size /= granularity\n\n\treturn np.exp(bestc), np.exp(bestg)\n</code></pre>"},{"location":"reference/#code.create_data.__cached__","title":"<code>__cached__ = 'C:\\\\Users\\\\avigh\\\\Documents\\\\python\\\\VoltageDimentionalReduction\\\\code\\\\__pycache__\\\\create_data.cpython-313.pyc'</code>  <code>module</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"reference/#code.create_data.__file__","title":"<code>__file__ = 'C:\\\\Users\\\\avigh\\\\Documents\\\\python\\\\VoltageDimentionalReduction\\\\code\\\\create_data.py'</code>  <code>module</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"reference/#code.create_data.__name__","title":"<code>__name__ = 'code.create_data'</code>  <code>module</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"reference/#code.create_data.__package__","title":"<code>__package__ = 'code'</code>  <code>module</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"reference/#code.create_data.Data","title":"<code>Data</code>","text":"<p>Class for handling and processing data sets.</p>"},{"location":"reference/#code.create_data.Data.__dict__","title":"<code>__dict__ = mappingproxy({'__module__': 'code.create_data', '__firstlineno__': 111, '__doc__': 'Class for handling and processing data sets.', '__init__': &lt;function Data.__init__ at 0x000001F6B4CF8220&gt;, '__len__': &lt;function Data.__len__ at 0x000001F6B4CF82C0&gt;, '__getitem__': &lt;function Data.__getitem__ at 0x000001F6B4CF8360&gt;, '__setitem__': &lt;function Data.__setitem__ at 0x000001F6B4CF8400&gt;, '__iter__': &lt;function Data.__iter__ at 0x000001F6B4CF84A0&gt;, '__next__': &lt;function Data.__next__ at 0x000001F6B4CF8540&gt;, 'getSubSet': &lt;function Data.getSubSet at 0x000001F6B4CF85E0&gt;, 'save_data_json': &lt;function Data.save_data_json at 0x000001F6B4CF8680&gt;, 'save_data_pickle': &lt;function Data.save_data_pickle at 0x000001F6B4CF8720&gt;, 'load_data_json': &lt;function Data.load_data_json at 0x000001F6B4CF87C0&gt;, 'load_data_pickle': &lt;function Data.load_data_pickle at 0x000001F6B4CF8860&gt;, 'stream_data_json': &lt;function Data.stream_data_json at 0x000001F6B4CF8900&gt;, 'file_function_pairs': [['json', &lt;function Data.save_data_json at 0x000001F6B4CF8680&gt;, &lt;function Data.load_data_json at 0x000001F6B4CF87C0&gt;], ['pkl', &lt;function Data.save_data_pickle at 0x000001F6B4CF8720&gt;, &lt;function Data.load_data_pickle at 0x000001F6B4CF8860&gt;]], 'data_function': &lt;function Data.data_function at 0x000001F6B4CF89A0&gt;, 'save_data': &lt;function Data.save_data at 0x000001F6B4CF8A40&gt;, 'load_data': &lt;function Data.load_data at 0x000001F6B4CF8AE0&gt;, 'get_random_point': &lt;function Data.get_random_point at 0x000001F6B4CF8B80&gt;, 'plot': &lt;function Data.plot at 0x000001F6B4CF8C20&gt;, 'getNumpy': &lt;function Data.getNumpy at 0x000001F6B4CF8CC0&gt;, '__static_attributes__': ('data', 'i', 'input_file', 'length', 'stream', 'streaming_data'), '__dict__': &lt;attribute '__dict__' of 'Data' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Data' objects&gt;})</code>  <code>class</code>","text":"<p>Read-only proxy of a mapping.</p>"},{"location":"reference/#code.create_data.Data.__doc__","title":"<code>__doc__ = 'Class for handling and processing data sets.'</code>  <code>class</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"reference/#code.create_data.Data.__firstlineno__","title":"<code>__firstlineno__ = 111</code>  <code>class</code>","text":"<p>int([x]) -&gt; integer int(x, base=10) -&gt; integer</p> <p>Convert a number or string to an integer, or return 0 if no arguments are given.  If x is a number, return x.int().  For floating-point numbers, this truncates towards zero.</p> <p>If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base.  The literal can be preceded by '+' or '-' and be surrounded by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal.</p> <p>int('0b100', base=0) 4</p>"},{"location":"reference/#code.create_data.Data.__module__","title":"<code>__module__ = 'code.create_data'</code>  <code>class</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"reference/#code.create_data.Data.__static_attributes__","title":"<code>__static_attributes__ = ('data', 'i', 'input_file', 'length', 'stream', 'streaming_data')</code>  <code>class</code>","text":"<p>Built-in immutable sequence.</p> <p>If no argument is given, the constructor returns an empty tuple. If iterable is specified the tuple is initialized from iterable's items.</p> <p>If the argument is a tuple, the return value is the same object.</p>"},{"location":"reference/#code.create_data.Data.__weakref__","title":"<code>__weakref__</code>  <code>property</code>","text":"<p>list of weak references to the object</p>"},{"location":"reference/#code.create_data.Data.file_function_pairs","title":"<code>file_function_pairs = [['json', &lt;function Data.save_data_json at 0x000001F6B4CF8680&gt;, &lt;function Data.load_data_json at 0x000001F6B4CF87C0&gt;], ['pkl', &lt;function Data.save_data_pickle at 0x000001F6B4CF8720&gt;, &lt;function Data.load_data_pickle at 0x000001F6B4CF8860&gt;]]</code>  <code>class</code>","text":"<p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p>"},{"location":"reference/#code.create_data.Data.data_function","title":"<code>data_function(file, save_or_load)</code>","text":"<p>Used for saving and loading the dataset</p>"},{"location":"reference/#code.create_data.Data.getSubSet","title":"<code>getSubSet(indexList)</code>","text":"<p>Returns a subset of the data given a list of indices.</p>"},{"location":"reference/#code.create_data.Data.get_random_point","title":"<code>get_random_point()</code>","text":"<p>Returns a random point from the dataset.</p>"},{"location":"reference/#code.create_data.Data.plot","title":"<code>plot(name=None)</code>","text":"<p>Plots the dataset.</p>"},{"location":"reference/#code.create_data.Data.stream_data_json","title":"<code>stream_data_json(input_file)</code>","text":"<p>Stream the dataset if its saved in a json file</p>"},{"location":"reference/#code.create_data.DataCreator","title":"<code>DataCreator</code>","text":""},{"location":"reference/#code.create_data.DataCreator.__dict__","title":"<code>__dict__ = mappingproxy({'__module__': 'code.create_data', '__firstlineno__': 366, '__init__': &lt;function DataCreator.__init__ at 0x000001F6B4CF9300&gt;, 'stream_dataset_creator': &lt;function DataCreator.stream_dataset_creator at 0x000001F6B4CF93A0&gt;, 'create_dataset_line': &lt;function DataCreator.create_dataset_line at 0x000001F6B4CF9440&gt;, 'create_dataset_square_edge': &lt;function DataCreator.create_dataset_square_edge at 0x000001F6B4CF94E0&gt;, 'create_dataset_square_fill': &lt;function DataCreator.create_dataset_square_fill at 0x000001F6B4CF9580&gt;, 'create_dataset_eigth_sphere': &lt;function DataCreator.create_dataset_eigth_sphere at 0x000001F6B4CF9620&gt;, 'create_dataset_triangle': &lt;function DataCreator.create_dataset_triangle at 0x000001F6B4CF96C0&gt;, 'create_dataset_strong_clusters': &lt;function DataCreator.create_dataset_strong_clusters at 0x000001F6B4CF9760&gt;, 'rotate_into_dimention': &lt;function DataCreator.rotate_into_dimention at 0x000001F6B4CF9800&gt;, 'create_dataset_spiral': &lt;function DataCreator.create_dataset_spiral at 0x000001F6B4CF98A0&gt;, '__static_attributes__': ('fg',), '__dict__': &lt;attribute '__dict__' of 'DataCreator' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'DataCreator' objects&gt;, '__doc__': None})</code>  <code>class</code>","text":"<p>Read-only proxy of a mapping.</p>"},{"location":"reference/#code.create_data.DataCreator.__firstlineno__","title":"<code>__firstlineno__ = 366</code>  <code>class</code>","text":"<p>int([x]) -&gt; integer int(x, base=10) -&gt; integer</p> <p>Convert a number or string to an integer, or return 0 if no arguments are given.  If x is a number, return x.int().  For floating-point numbers, this truncates towards zero.</p> <p>If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base.  The literal can be preceded by '+' or '-' and be surrounded by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal.</p> <p>int('0b100', base=0) 4</p>"},{"location":"reference/#code.create_data.DataCreator.__module__","title":"<code>__module__ = 'code.create_data'</code>  <code>class</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"reference/#code.create_data.DataCreator.__static_attributes__","title":"<code>__static_attributes__ = ('fg',)</code>  <code>class</code>","text":"<p>Built-in immutable sequence.</p> <p>If no argument is given, the constructor returns an empty tuple. If iterable is specified the tuple is initialized from iterable's items.</p> <p>If the argument is a tuple, the return value is the same object.</p>"},{"location":"reference/#code.create_data.DataCreator.__weakref__","title":"<code>__weakref__</code>  <code>property</code>","text":"<p>list of weak references to the object</p>"},{"location":"reference/#code.create_data.DataCreator.create_dataset_eigth_sphere","title":"<code>create_dataset_eigth_sphere(output_file=None, radius=1, x_pos=True, y_pos=True, z_pos=True, points=1000, seed=42, stream=False)</code>","text":"<p>Generates a dataset of an eigth sphere</p>"},{"location":"reference/#code.create_data.DataCreator.create_dataset_line","title":"<code>create_dataset_line(output_file=None, start=0, end=1, points=1000, seed=42, stream=False)</code>","text":"<p>Generates a dataset of a 1D line</p>"},{"location":"reference/#code.create_data.DataCreator.create_dataset_square_edge","title":"<code>create_dataset_square_edge(output_file=None, p1=(0, 0), p2=(1, 1), points=1000, seed=42)</code>","text":"<p>Generates a dataset of the edge of a square</p>"},{"location":"reference/#code.create_data.DataCreator.create_dataset_square_fill","title":"<code>create_dataset_square_fill(output_file=None, p1=(0, 0), p2=(1, 1), points=1000, seed=42)</code>","text":"<p>Generates a dataset of a filled in square</p>"},{"location":"reference/#code.create_data.DataCreator.create_dataset_strong_clusters","title":"<code>create_dataset_strong_clusters(output_file=None, internal_std=1, external_std=10, mean=[0, 0], clusters=10, points=1000, seed=42, stream=False)</code>","text":"<p>Generates a strongly clustered datapoint by selecting cluster centers and variance in the clusters via normal distribution</p>"},{"location":"reference/#code.create_data.DataCreator.create_dataset_triangle","title":"<code>create_dataset_triangle(output_file=None, edges=[[0, 0], [1, 1], [2, 0]], points=1000, seed=42, stream=False)</code>","text":"<p>Generates a dataset of an eigth sphere</p>"},{"location":"reference/#code.create_data.DataCreator.rotate_into_dimention","title":"<code>rotate_into_dimention(data, higher_dim=3, seed=42)</code>","text":"<p>Moves the data into a higher dimention and does rotations centered at the origin</p>"},{"location":"reference/#code.create_data.DataCreator.stream_dataset_creator","title":"<code>stream_dataset_creator(output_file, function, seed, stream, *args)</code>","text":"<p>Creates a dataset by passing in generator functions, allowing for streamed and not streamed dataset creation</p>"},{"location":"reference/#code.create_data.FileGenerator","title":"<code>FileGenerator</code>","text":"<p>Generates files for saved data. Its own class because it is used by Data and DataCreator</p>"},{"location":"reference/#code.create_data.FileGenerator.__dict__","title":"<code>__dict__ = mappingproxy({'__module__': 'code.create_data', '__firstlineno__': 293, '__doc__': 'Generates files for saved data. Its own class because it is used by Data and DataCreator', '__init__': &lt;function FileGenerator.__init__ at 0x000001F6B4CF8D60&gt;, 'setGenerator': &lt;function FileGenerator.setGenerator at 0x000001F6B4CF8E00&gt;, 'stream_save': &lt;function FileGenerator.stream_save at 0x000001F6B4CF8EA0&gt;, 'linear_generator': &lt;function FileGenerator.linear_generator at 0x000001F6B4CF8F40&gt;, 'line_generator': &lt;function FileGenerator.line_generator at 0x000001F6B4CF8FE0&gt;, 'eigth_sphere_generator': &lt;function FileGenerator.eigth_sphere_generator at 0x000001F6B4CF9080&gt;, 'triangle_generator': &lt;function FileGenerator.triangle_generator at 0x000001F6B4CF9120&gt;, 'strong_cluster_generator': &lt;function FileGenerator.strong_cluster_generator at 0x000001F6B4CF91C0&gt;, 'spiral_generator': &lt;function FileGenerator.spiral_generator at 0x000001F6B4CF9260&gt;, '__static_attributes__': ('data_generator',), '__dict__': &lt;attribute '__dict__' of 'FileGenerator' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'FileGenerator' objects&gt;})</code>  <code>class</code>","text":"<p>Read-only proxy of a mapping.</p>"},{"location":"reference/#code.create_data.FileGenerator.__doc__","title":"<code>__doc__ = 'Generates files for saved data. Its own class because it is used by Data and DataCreator'</code>  <code>class</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"reference/#code.create_data.FileGenerator.__firstlineno__","title":"<code>__firstlineno__ = 293</code>  <code>class</code>","text":"<p>int([x]) -&gt; integer int(x, base=10) -&gt; integer</p> <p>Convert a number or string to an integer, or return 0 if no arguments are given.  If x is a number, return x.int().  For floating-point numbers, this truncates towards zero.</p> <p>If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base.  The literal can be preceded by '+' or '-' and be surrounded by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal.</p> <p>int('0b100', base=0) 4</p>"},{"location":"reference/#code.create_data.FileGenerator.__module__","title":"<code>__module__ = 'code.create_data'</code>  <code>class</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"reference/#code.create_data.FileGenerator.__static_attributes__","title":"<code>__static_attributes__ = ('data_generator',)</code>  <code>class</code>","text":"<p>Built-in immutable sequence.</p> <p>If no argument is given, the constructor returns an empty tuple. If iterable is specified the tuple is initialized from iterable's items.</p> <p>If the argument is a tuple, the return value is the same object.</p>"},{"location":"reference/#code.create_data.FileGenerator.__weakref__","title":"<code>__weakref__</code>  <code>property</code>","text":"<p>list of weak references to the object</p>"},{"location":"reference/#code.create_data.FileGenerator.eigth_sphere_generator","title":"<code>eigth_sphere_generator(radius, x_pos, y_pos, z_pos, points)</code>","text":"<p>Generator for points on an eigth sphere</p>"},{"location":"reference/#code.create_data.FileGenerator.line_generator","title":"<code>line_generator(start, end, points)</code>","text":"<p>Generates points along a line in 1D space.</p>"},{"location":"reference/#code.create_data.FileGenerator.linear_generator","title":"<code>linear_generator(data)</code>","text":"<p>Yields data points one by one.</p>"},{"location":"reference/#code.create_data.FileGenerator.stream_save","title":"<code>stream_save(output_file, *args)</code>","text":"<p>Saves data to a JSON file in a streaming manner.</p>"},{"location":"reference/#code.create_data.FileGenerator.strong_cluster_generator","title":"<code>strong_cluster_generator(internal_std, cluster_centers, points)</code>","text":"<p>Generates points in a strong cluster</p>"},{"location":"reference/#code.create_data.FileGenerator.triangle_generator","title":"<code>triangle_generator(edges, points)</code>","text":"<p>Generator for points on a triangle</p>"},{"location":"reference/#code.create_data.Plotter","title":"<code>Plotter</code>","text":"<p>Graphs the data into different formats</p>"},{"location":"reference/#code.create_data.Plotter.__dict__","title":"<code>__dict__ = mappingproxy({'__module__': 'code.create_data', '__firstlineno__': 30, '__doc__': 'Graphs the data into different formats', 'pointFormatting': &lt;function Plotter.pointFormatting at 0x000001F6B4CDBF60&gt;, 'plotPoints': &lt;function Plotter.plotPoints at 0x000001F6B4CF8040&gt;, 'plotPointSets': &lt;function Plotter.plotPointSets at 0x000001F6B4CF80E0&gt;, 'voltage_plot': &lt;function Plotter.voltage_plot at 0x000001F6B4CF8180&gt;, '__static_attributes__': (), '__dict__': &lt;attribute '__dict__' of 'Plotter' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Plotter' objects&gt;})</code>  <code>class</code>","text":"<p>Read-only proxy of a mapping.</p>"},{"location":"reference/#code.create_data.Plotter.__doc__","title":"<code>__doc__ = 'Graphs the data into different formats'</code>  <code>class</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"reference/#code.create_data.Plotter.__firstlineno__","title":"<code>__firstlineno__ = 30</code>  <code>class</code>","text":"<p>int([x]) -&gt; integer int(x, base=10) -&gt; integer</p> <p>Convert a number or string to an integer, or return 0 if no arguments are given.  If x is a number, return x.int().  For floating-point numbers, this truncates towards zero.</p> <p>If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base.  The literal can be preceded by '+' or '-' and be surrounded by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal.</p> <p>int('0b100', base=0) 4</p>"},{"location":"reference/#code.create_data.Plotter.__module__","title":"<code>__module__ = 'code.create_data'</code>  <code>class</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"reference/#code.create_data.Plotter.__static_attributes__","title":"<code>__static_attributes__ = ()</code>  <code>class</code>","text":"<p>Built-in immutable sequence.</p> <p>If no argument is given, the constructor returns an empty tuple. If iterable is specified the tuple is initialized from iterable's items.</p> <p>If the argument is a tuple, the return value is the same object.</p>"},{"location":"reference/#code.create_data.Plotter.__weakref__","title":"<code>__weakref__</code>  <code>property</code>","text":"<p>list of weak references to the object</p>"},{"location":"reference/#code.create_data.Plotter.plotPointSets","title":"<code>plotPointSets(sets, name=None)</code>","text":"<p>Plots multiple sets of points with different colors and markers.</p>"},{"location":"reference/#code.create_data.Plotter.plotPoints","title":"<code>plotPoints(points, name=None)</code>","text":"<p>Plots a set of points in 2D or 3D.</p>"},{"location":"reference/#code.create_data.Plotter.pointFormatting","title":"<code>pointFormatting(points)</code>","text":"<p>Formats points into coordinate lists for plotting.</p>"},{"location":"reference/#code.create_data.dimentional_variation","title":"<code>dimentional_variation(dimentions)</code>","text":"<p>Returns an np array that is full of random variables from -inf to inf based on the standard normal distribution</p>"},{"location":"reference/#code.create_data.select_random","title":"<code>select_random(array)</code>","text":"<p>Selects a random element from an array.</p>"},{"location":"reference/#code.kmeans.Partitions","title":"<code>Partitions</code>","text":"<p>               Bases: <code>DistanceBased</code></p> <p>Using K-means to partition a large dataset</p> Source code in <code>code\\kmeans.py</code> <pre><code>class Partitions(DistanceBased):\n\t\"\"\"Using K-means to partition a large dataset\"\"\"\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tsuper().__init__()\n\n\tdef k_means_plus_plus(self, k):\n\t\t# print(self.data.data)\n\t\tself.centers = [create_data.select_random(self.data)]\n\n\t\tfor i in range(k - 1):\n\t\t\tdistances = []\n\n\t\t\tfor point in self.data:\n\t\t\t\t# print(type(point))\n\t\t\t\t# print(type(self.centers[0]))\n\n\t\t\t\t# print(point)\n\t\t\t\t# print(self.centers[0])\n\n\t\t\t\td = self.distance(point, self.centers[0])\n\t\t\t\tfor center in self.centers:\n\t\t\t\t\td = min(d, self.distance(point, center))\n\n\t\t\t\tdistances.append(d)\n\n\t\t\tdistances = np.array(distances)\n\t\t\tdistances /= np.sum(distances)\n\n\t\t\tself.centers.append(weighted_random(self.data, distances))\n\n\t\treturn self.centers\n\n\tdef k_means(self, k, seed=42, savePointAssignments=False):\n\t\tif (seed == -1):\n\t\t\tkmeans = KMeans(n_clusters=k, init=\"k-means++\").fit(self.data)\n\t\telse:\n\t\t\tkmeans = KMeans(n_clusters=k, random_state=int(seed), init=\"k-means++\", n_init=1).fit(self.data)\n\n\t\tself.k = k\n\t\tself.centers = kmeans.cluster_centers_\n\t\tself.point_counts = np.bincount(kmeans.labels_).tolist()\n\n\t\tif savePointAssignments:\n\t\t\tself.point_assignments = [[] for i in range(k)]\n\t\t\tfor i, point in enumerate(data):\n\t\t\t\tlabel = kmeans.labels_[i]\n\n\t\t\t\t# print(point)\n\t\t\t\t# print(self.centers[label])\n\t\t\t\t# print(self.distance(point, self.centers[label]))\n\t\t\t\tself.point_assignments[label].append([point, self.distance(point, self.centers[label])])\n\n\t\t\t# self.point_assignments = [data[kmeans.labels_ == i] for i in range(k)]\t# k times less efficient\n\t\t# self.voronoi = Voronoi(self.centers)\n\n\tdef my_k_means(self, k, seed=42, savePointAssignments=False):\n\t\tif (seed != -1):\n\t\t\trandom.seed(seed)\n\n\t\tself.centers = self.k_means_plus_plus(k)\n\n\t\tpoint_accumulator = [np.zeros(len(self.data[0])) for i in range(k)]\n\t\tpoint_counts = [0 for i in range(k)]\n\n\t\tif (savePointAssignments):\t\t\t\t\t\t\t\t\t\t\t\t\t\t# This removes the benefit of streaming\n\t\t\tself.point_assignments = [[] for i in range(k)]\n\n\t\tfor i, point in enumerate(self.data):\n\t\t\tmin_index = 0\n\t\t\tmin_dist = self.distance(point, self.centers[0])\n\n\t\t\tfor c in range(k - 1):\n\t\t\t\tdist = self.distance(point, self.centers[c + 1])\n\t\t\t\tif (min_dist &gt; dist):\n\t\t\t\t\tmin_index = c + 1\n\t\t\t\t\tmin_dist = dist\n\n\t\t\tif (savePointAssignments):\n\t\t\t\tself.point_assignments[min_index].append([point, min_dist])\n\n\t\t\tpoint_accumulator[min_index] += point\n\t\t\tpoint_counts[min_index] += 1\n\n\t\tupdated_centers = []\n\t\tself.point_counts = []\n\n\t\tfor acc, count in zip(point_accumulator, point_counts):\n\t\t\tif (count != 0):\n\t\t\t\tupdated_centers.append(acc / count)\n\t\t\t\tself.point_counts.append(count)\n\n\t\tself.centers = updated_centers\n\t\tself.voronoi = Voronoi(self.centers)\n\n\tdef getClosestPoints(self, index):\n\t\tclosest = []\n\t\tfor i, point in enumerate(self.data):\n\t\t\tmin_index = 0\n\t\t\tmin_dist = self.distance(point, self.centers[0])\n\n\t\t\tfor c in range(len(self.centers) - 1):\n\t\t\t\tdist = self.distance(point, self.centers[c + 1])\n\t\t\t\tif (min_dist &gt; dist):\n\t\t\t\t\tmin_index = c + 1\n\t\t\t\t\tmin_dist = dist\n\n\t\t\tif (min_index == index):\n\t\t\t\tclosest.append(i)\n\n\t\treturn closest\n\n\tdef plot(self, color='r', marker='o', ax=None, name=None):\n\t\tplot = create_data.Plotter()\n\n\t\tsize = len(self.centers[0])\n\n\t\tif (ax == None):\n\t\t\tfig = plt.figure()\n\n\t\t\tif (size == 3):\n\t\t\t\tax = fig.add_subplot(111, projection='3d')\n\t\t\telse:\n\t\t\t\tax = fig.add_subplot(111)\n\n\t\tif (size == 3):\n\t\t\t(x_coords, y_coords, z_coords) = plot.pointFormatting(self.centers)\n\t\t\tax.scatter(x_coords, y_coords, z_coords, c=color, marker=marker, label='Centers')\n\t\telse:\n\t\t\t(x_coords, y_coords, z_coords) = plot.pointFormatting(self.data)\n\t\t\tax.scatter(x_coords, y_coords, c=color, marker=marker, label='Points')\n\n\t\t\t# voronoi_plot_2d(self.voronoi, ax=ax, show_vertices=False, line_colors='blue', line_width=1, line_alpha=0.6)\n\n\t\tax.legend()\n\n\t\tif (name):\n\t\t\tplt.savefig(name)\n\n\t\tplt.show()\n</code></pre>"},{"location":"reference/#code.voltage.Landmark","title":"<code>Landmark</code>","text":"<p>Defines at which index datapoint will a voltage be applied to. Indicies could be either partition centers or data points themselves</p> Source code in <code>code\\voltage.py</code> <pre><code>class Landmark():\n\t\"\"\"Defines at which index datapoint will a voltage be applied to. Indicies could be either partition centers or data points themselves\"\"\"\n\tdef __init__(self, index, voltage):\n\t\tself.index = index\n\t\tself.voltage = voltage\n\n\t@staticmethod\n\tdef createLandmarkClosestTo(data, point, voltage, distanceFn=None, ignore=[]):\n\t\tif (distanceFn == None):\n\t\t\tdistanceFn = kmeans.DistanceBased()\n\n\t\tmost_central_index = 0\n\t\tmindist = distanceFn.distance(data[0], point)\n\n\t\tfor index in range(1, len(data)):\n\t\t\tif (index in ignore):\n\t\t\t\tcontinue\n\n\t\t\tdist = distanceFn.distance(data[index], point)\n\t\t\tif dist &lt; mindist:\n\t\t\t\tmost_central_index = index\n\t\t\t\tmindist = dist\n\n\t\treturn Landmark(most_central_index, voltage)\n</code></pre>"},{"location":"reference/#code.voltage.Problem","title":"<code>Problem</code>","text":"<p>               Bases: <code>DistanceBased</code></p> <p>Represents the problem that is trying to be solved</p> Source code in <code>code\\voltage.py</code> <pre><code>class Problem(kmeans.DistanceBased):\n\t\"\"\"Represents the problem that is trying to be solved\"\"\"\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.landmarks = []\n\t\tn = len(data)\n\t\tself.weights = np.zeros([len(data), len(data)])\n\t\tself.universalGround = False\n\t\tsuper().__init__()\n\n\tdef timeStart(self):\n\t\tself.start = time.time()\n\n\tdef timeEnd(self, replace=True):\n\t\tcurTime = time.time()\n\t\tdiff = curTime - self.start\n\n\t\tif (replace):\n\t\t\tself.start = curTime\n\n\t\treturn diff\n\n\tdef setKernel(self, kernel):\n\t\tself.kernel = kernel\n\n\tdef efficientSquareDistance(self, data):\n\t\tdata_norm2 = np.sum(data**2, axis=1)\n\n\t\tx_norm2 = data_norm2.reshape(-1, 1)\t\t\t\t# shape: (n, 1)\n\t\ty_norm2 = data_norm2.reshape(1, -1)\t\t\t\t# shape: (1, n)\n\t\treturn x_norm2 + y_norm2 - 2 * data @ data.T\t# shape: (n, n)\n\n\tdef radialkernel(self, data, r):\n\t\tdist2 = self.efficientSquareDistance(data)\n\t\treturn (dist2 &lt;= r**2).astype(float)\n\n\tdef gaussiankernel(self, data, std):\n\t\tdist2 = self.efficientSquareDistance(data)\n\t\treturn np.exp(-dist2 / (2 * std**2))\n\n\tdef setWeights(self, *c):\n\t\tn = len(self.data)\n\n\t\tdata = self.data.getNumpy()\n\n\t\t# print(data.shape)\n\n\t\tself.weights[:n, :n] = self.kernel(data, *c)\n\n\t\tself.normalizeWeights()\n\n\t\treturn self.weights\n\n\tdef normalizeWeights(self):\n\t\tself.weights = self.weights / self.weights.sum(axis=1, keepdims=True)\n\n\t\tif np.isnan(self.weights).any():\n\t\t\traise ValueError(\"Array contains NaN values!\")\n\n\tdef setPartitionWeights(self, partition, *c):\n\t\tn = len(partition.centers)\n\t\tcenters = np.array(partition.centers)\n\t\tcounts = np.array(partition.point_counts).reshape(-1, 1)\n\n\t\tK = self.kernel(centers[:, None], centers[None, :], *c)\n\n\t\tW = K * (counts @ counts.T)\n\n\t\tself.weights[:n, :n] = W\n\t\tself.normalizeWeights()\n\t\treturn self.weights\n\n\tdef addUniversalGround(self, p_g=0.01):\n\t\tif (self.universalGround):\n\t\t\tn = self.weights.shape[0] - 1\n\n\t\t\tfor x in range(n):\t\t\t\t# W[g, g] = 0\n\t\t\t\tself.weights[x][n] = p_g / n\n\t\t\t\tself.weights[n][x] = p_g / n\n\n\t\telse:\n\t\t\tself.universalGround = True\n\n\t\t\tn = self.weights.shape[0]\n\t\t\tnewW = np.zeros([n + 1, n + 1])\n\n\t\t\tnewW[0:n,0:n] = self.weights\n\n\t\t\tfor x in range(0, n):\t\t\t# W[g, g] = 0\n\t\t\t\tnewW[x][n] = p_g / n\n\t\t\t\tnewW[n][x] = p_g / n\n\n\t\t\tself.weights = newW\n\t\t\tself.addLandmark(Landmark(n, 0))\n\n\t\tself.normalizeWeights()\n\n\t\treturn self.weights\n\n\tdef addLandmark(self, landmark):\n\t\tself.landmarks.append(landmark)\n\n\tdef addLandmarks(self, landmarks):\n\t\tself.landmarks += landmarks\n\n\tdef addLandmarksInRange(self, minRange, maxRange, voltage):\n\t\tadding = []\n\t\tfor index, point in enumerate(data):\n\t\t\tif np.all(point &gt;= minRange) and np.all(point &lt;= maxRange):\n\t\t\t\tadding.append(Landmark(index, voltage))\n\n\t\tself.addLandmarks(adding)\n\t\treturn adding\n</code></pre>"},{"location":"reference/#code.voltage.Solver","title":"<code>Solver</code>","text":"<p>               Bases: <code>DistanceBased</code></p> <p>Solves a given Problem</p> Source code in <code>code\\voltage.py</code> <pre><code>class Solver(kmeans.DistanceBased):\n\t\"\"\"Solves a given Problem\"\"\"\n\tdef __init__(self, problem):\n\t\tself.problem = problem\n\t\tsuper().__init__()\n\n\tdef compute_voltages(self):\n\t\tn = self.problem.weights.shape[0]\n\n\t\tconstrained_nodes =   [l.index for l in self.problem.landmarks]\n\t\tunconstrained_nodes = [i for i in range(n) if i not in constrained_nodes]\n\n\t\tb = np.zeros(n)\n\t\tfor landmark in self.problem.landmarks:\n\t\t\tfor y in range(0, n):\n\t\t\t\tb[y] += landmark.voltage * self.problem.weights[y][landmark.index]\n\n\t\tA_unconstrained = np.identity(len(unconstrained_nodes)) - self.problem.weights[np.ix_(unconstrained_nodes, unconstrained_nodes)]\n\n\t\tb_unconstrained = b[unconstrained_nodes]\n\n\t\t# print(self.problem.weights)\n\t\t# print(A_unconstrained)\n\t\t# print(b_unconstrained)\n\n\t\tv_unconstrained = solve(A_unconstrained, b_unconstrained)\n\n\t\t# print(v_unconstrained)\n\n\t\tself.voltages = np.zeros(n)\n\n\t\tfor landmark in self.problem.landmarks:\n\t\t\tself.voltages[landmark.index] = landmark.voltage\n\n\t\tself.voltages[unconstrained_nodes] = v_unconstrained\n\n\t\tif (self.problem.universalGround):\n\t\t\tself.voltages = self.voltages[:-1]\n\n\t\treturn self.voltages\n\n\tdef approximate_voltages(self, epsilon=None, max_iters=None):\n\t\tn = self.problem.weights.shape[0]\n\n\t\tif (epsilon == None):\n\t\t\tif (max_iters == None):\n\t\t\t\tepsilon = 1 / n\n\n\t\tconstrained_nodes =\t\t[l.index for l in self.problem.landmarks]\n\t\tconstraints = \t\t\t[l.voltage for l in self.problem.landmarks]\n\t\tunconstrained_nodes =\t[i for i in range(n) if i not in constrained_nodes]\n\n\t\tself.voltages = np.zeros(n)\n\t\tvoltages = np.zeros(n)\n\n\t\tfor landmark in self.problem.landmarks:\n\t\t\tself.voltages[landmark.index] = landmark.voltage\n\n\t\tdist = self.distance(self.voltages, voltages)\n\t\tprev_dist = float('inf')\n\n\t\titerations = 0\n\n\t\twhile (((epsilon != None and dist &gt; epsilon * len(self.problem.data)) or (max_iters != None and iterations &lt; max_iters)) and dist &lt; prev_dist):\n\t\t\tvoltages = np.matmul(self.problem.weights, self.voltages)\n\t\t\tvoltages[constrained_nodes] = constraints\n\t\t\tprev_dist = dist\n\t\t\tdist = self.distance(self.voltages, voltages)\n\n\t\t\t# print(prev_dist, dist)\n\n\t\t\tself.voltages = voltages\n\t\t\titerations += 1\n\n\t\t# print(iterations)\n\n\t\tif (self.problem.universalGround):\n\t\t\tself.voltages = self.voltages[:-1]\n\n\t\treturn self.voltages\n\n\tdef localSolver(self, partitions, c):\n\t\tvoltages = [0 for i in range(len(self.problem.data))]\n\n\t\tfor index in range(partitions.k):\n\t\t\tclosestIndicies = partitions.getClosestPoints(index)\n\t\t\tcloseproblem.LandmarksIndicies = []\n\n\t\t\tfor pair in partitions.voronoi.ridge_points:\n\t\t\t\tif pair[0] == index:\n\t\t\t\t\tcloseproblem.LandmarksIndicies.append(pair[1])\n\t\t\t\tif pair[1] == index:\n\t\t\t\t\tcloseproblem.LandmarksIndicies.append(pair[0])\n\n\t\t\tcloseproblem.Landmarks = []\n\t\t\tfor cli in closeproblem.LandmarksIndicies:\n\t\t\t\tcloseproblem.Landmarks.append(Landmark(cli, self.voltages[cli]))\n\n\t\t\tlocalSolver = Solver(self.problem.data.getSubSet(closestIndicies))\n\t\t\tlocalSolver.setKernel(self.problem.gaussiankernel)\n\t\t\tlocalSolver.setWeights(c)\n\t\t\tlocalSolver.addproblem.Landmarks(closeproblem.Landmarks)\n\t\t\tlocalVoltages = localSolver.compute_voltages()\n\n\t\t\tfor i, v in zip(closestIndicies, localVoltages):\n\t\t\t\tvoltages[i] = v\n\n\t\treturn voltages\n</code></pre>"}]}